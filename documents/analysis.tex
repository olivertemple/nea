\documentclass{article}

\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{style=mystyle}

\usetikzlibrary{shapes,arrows}
\newcommand{\comment}[1]{}


\tikzstyle{decision} = [diamond, draw, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{block} = [rectangle, draw, 
    text width=8em, text centered, rounded corners, minimum height=4em]
\tikzstyle{start} = [rectangle, draw, 
    text width=4.5em, text badly centered, rounded corners, node distance=3cm]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black]


\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{4}

\pagestyle{fancy}
\fancyhf{}
\rhead{Path-finding Algorithms and Solving Mazes}
\lhead{Oliver Temple [CN]}
\rfoot{\thepage}
\lfoot{Path-finding Algorithms and Solving Mazes}

\title{Path-finding Algorithms and Solving Mazes}

\author{Oliver Temple}

\begin{document}

\maketitle
\tableofcontents

\section{analysis}
\subsection{Project Description}
Path finding algorithms are essential in many aspects computer science, especially in games and simulations. However, they can be complex things that are hard to visualize, especially when being taught about them. Path finding algorithm visualizers do exist, however, I feel that none of them are perfect.

Because of this, I am going to make a path finding visualizer that ticks all of the boxes. It will be simple and easy to use, have advanced customization and have the ability to run a path finding algorithms given by the user.

\subsection{Research}
\subsubsection{Overview}
To complete this project, I will need a strong understanding of maze generation and path finding algorithms, how they work and how to model them, knowledge of react and javascript to create a website for the visualization as well as user opinions on what features are needed.
\subsubsection{Research Log}
\paragraph*{Class}
I was introduced to path finding algorithms in one of my lessons, where we learned what they were used for and some examples, as well as how they can be modeled. For example, modelling the maze as a graph with weighted nodes of 1 and 0, for the walls and space respectively. The algorithms we looked at were Dijkstra's and A*. We also looked at Prim's algorithm, recursive backtracking, depth fist search and Kruskal's algorithms for maze generation.

\subsection{Project Background}
\subsubsection{Current Systems}
\paragraph{Example 1}
\href{https://clementmihailescu.github.io/Pathfinding-Visualizer/
}{https://clementmihailescu.github.io/Pathfinding-Visualizer
}
\newline
In this example, mazes can be generated with various algorithms, as well as being drawn by the user. The mazes can also be edited after they have been generated. The available maze generation algorithms are:
\begin{itemize}
    \item Recursive Division
    \item Recursive Division (vertical skew)
    \item Recursive Division (horizontal skew)
    \item Basic Random Maze
    \item Basic Weight Maze
    \item Simple Stair Pattern
\end{itemize}
These mazes can then be solved with a number of different path finding algorithms. The available path finding algorithms are:
\begin{itemize}
    \item Djikstra's Algorithm
    \item A* Search
    \item Greedy Best-first Search
    \item Swarm Algorithm
    \item Convergent Swarm Algorithm
    \item Bidirectional Swarm Algorithm
    \item Breadth-first Search
    \item Depth-first Search
\end{itemize}
\includegraphics[width=\linewidth]{assets/Existing Solutions/example 1.PNG}
\subparagraph*{pros}
\begin{itemize}
    \item Many different algorithms to choose from.
    \item Start and end nodes can be moved.
    \item Maze can be altered.
    \item If nodes are moved after visualization has run, then the visualization will update.
    \item "Bomb" node, adds a via point that the path must go through.
\end{itemize}
\subparagraph*{cons}
\begin{itemize}
    \item The visualization is too slow.
    \item If maze is altered by user after visualization has run, then the visualization will not update.
\end{itemize}


\paragraph{Example 2}
\href{https://qiao.github.io/PathFinding.js/visual/
}{https://qiao.github.io/PathFinding.js/visual/
}
\newline
In this example, mazes have to be drawn by the user. The maze can then be solved with a number of different algorithms, however, these algorithms have more choice. For example, in the A* option, you can change the heuristic that is used. The available algorithms are:
\begin{itemize}
    \item A*
    \item IDA*
    \item Breadth-First-Search
    \item Best-First-Search
    \item Dijkstra
    \item Jump Point Search
    \item Orthogonal Jump Point Search
    \item Trace
\end{itemize}
\includegraphics[width=\linewidth]{assets/Existing Solutions/example 2.PNG}
\subparagraph*{pros}
\begin{itemize}
    \item More options to choose from within each algorithm.
\end{itemize}
\subparagraph*{cons}
\begin{itemize}
    \item No maze generation.
    \item Visualization does not update when maze or start/finnish nodes are changed.
\end{itemize}


\paragraph{Example 3}
\href{https://pathfindout.com/
}{https://pathfindout.com/
}
\newline
In this example, mazes can be generated or drawn, however, mazes can only be generated with the recursive division algorithm. There are fewer path finding algorithms to solve the mazes than the others. The available algorithms are:
\begin{itemize}
    \item Dijkstra's Algorithm
    \item A* Search
    \item Breadth First Search
    \item Depth First Search
\end{itemize}
\includegraphics[width=\linewidth]{assets/Existing Solutions/example 3.PNG}
\subparagraph*{pros}
\begin{itemize}
    \item Different weighted nodes available.
    \item Shows how many nodes visited.
    \item Shows final path length.
    \item Data structure for some algorithms can be changed.
    \item Weights of specific node types can be changed.
    \item Node size can be changed.
\end{itemize}
\subparagraph*{cons}
\begin{itemize}
    \item Sometimes generates mazes that cannot be solved.
    \item Cannot edit maze after visualization has run.
    \item Only one maze generation algorithm.
    \item Fewer path finding algorithms to solve the maze.
\end{itemize}

\subsubsection{Proposed Solution}
I will make a path-finding visualization that encompasses as many of the merits of the existing solutions as possible, while also tackling as many of the drawbacks.
\begin{itemize}
    \item Research the different algorithms needed and write the corresponding pseudoscode.
    \item Create a mockup of the user interface.
    \item Create the user interface in react.
    \item Code the algorithms in python.
    \item Create an AWS lambda function in python that runs the algorithms as an API.
    \item Create the react website to visualize the algorithms.
    \item Add additional features suggested by end users.
    \item Test visualization and check that it meets all of the objectives.
\end{itemize}
\subsubsection{Prospective Users}
The users of this system will most likely consist of teachers and students who are learning about path finding algorithms as it will clearly show how the algorithms function.
\paragraph{Questions To Users}
I asked some prospective users some questions about what they would like to see in the visualizer.
\paragraph*{Questions}
\begin{enumerate}
    \item[Q1.]What algorithms would you like to see for maze generation?
    \item[Q2.]What algorithms would you like to see for solving the maze?
    \item[Q3.]What additional features would you like to see in the path finding visualization?
    \item[Q4.]Would it be useful to be able to write your own path finding algorithms that can be run in the visualization?  
\end{enumerate}
\paragraph*{Answers}
\begin{enumerate}
    \item[A1.]I would like to see recursive backtracking and Prim's algorithms used for maze generation, as well as Kruskal's (less important). This is because Kruskal's and Prims are similar but each has their own advantages and disadvantages and recursive backtracking is different and uses recursion.
    \item[A2.]I would like to see Dijkstra's algorithm and A* search, as these are very popular algorithms and one is a heuristic, allowing the visualization to show the difference between an algorithm and a heuristic.
    \item[A3.]Option to add your own png image for the drawing of final path - "a sussy imposter running around the maze".
    \item[A4.]I would find it useful to be able to code my own algorithms. This would allow me to use the visualization with other, lesser known algorithms that I may need.
\end{enumerate}
The answers to these questions confirms what is required from the visualization, which will be reflected in the objectives. The need for contrasting algorithms is something that I will consider when deciding what algorithms to use.
\subsection{Objectives}
\subsubsection{Generate Mazes}
The website should be able to generate mazes using multiple algorithms, including, but not limited to: Prim's algorithm, recursive backtracking and random generation. There should also be a brief description of the algorithm that has been selected and its advantages and disadvantages.

\subsubsection{User Drawn Mazes}
The user should be able to draw mazes and obstacles easily on the grid using the mouse.

\subsubsection{Solve Mazes}
The website should be able to solve mazes using multiple algorithms, including, but not limited to: A* search, Dijkstra's algorithms, depth-first search and breadth-first search. There should also be a brief description of the algorithm that has been selected and its advantages and disadvantages.

\subsubsection{User written algorithms}
The website should be able to run algorithms written by the user for both maze generation and solving. This will be done by supplying documentation on what parameters need to be taken in and what will need to be returned from the function for the visualizer to work.

%\subsubsection{Update Visualization}
%If the maze is altered or and nodes moved once the visualization has been run, then it should update without rerunning the visualization.

\subsubsection{Special Nodes}
There should be "special" nodes that are different from walls or space. For example, nodes with different weights or a "via point" node that the path must go through.

\section{Documented Design}
\subsection{Visualization Structure}
There will be a python API for generating and solving the mazes, and a react website that will visualize the algorithms. There will be two API endpoints, on for generating the mazes and on for solving the mazes, hosted using AWS Lambda. 
\includegraphics[width=\linewidth]{assets/structure.jpg}
\subsection{Flow Chart}
\includegraphics[width=\linewidth, height=17.5cm]{assets/flow chart.PNG}

\comment{
\begin{tikzpicture}[node distance = 2cm, auto]
    \node[start] (init) {start};
    \node [io, below of = init] (1) {User selects maze algorithm};
    \node[block, below of = 1] (2) {Generate maze using selected algorithm};
    \node [io, below of=2](3){User selects path finding algorithm};
    \node[decision, below of=3](4){Start button pressed?};
    \node[block, below of=4, yshift=-1cm](5){Visualization runs};
    \node[decision, below of=5](6){Reset button pressed?};
    \node[decision, right of=6, xshift=1cm](7){Nodes moved?};
    \node[block, below of=7, xshift=0.25cm, yshift=-0.5cm](8){Update visualization};
    \node[block, below of=6, yshift=-0.5cm](9){Visualization resets};

    \path[line] (init) -- (1);
    \path[line] (1) -- (2);
    \path[line] (2) -- (3);
    \path[line] (3) -- (4);
    \path[line] (4) -- node {no}(4);
    \path[line] (4) -- node {yes}(5);
    \path[line] (5) -- (6);
    \path[line] (6) -- node {no}(7);
    \path[line] (6) -- node {yes}(9);
    \path[line] (7) -- node {yes}(8);
    \path[line] (7) -- node {no}(6);
    \path[line] (8) -- (6);
    \path[line, anchor=west] (9) -- (init);
\end{tikzpicture}}

\subsection{User Interface}
I have used Figma to create a design mockup of how the user interface will look. This allows me to plan what user inputs will be needed.
\newline
\includegraphics[width=\linewidth]{assets/gui.PNG}
\subsection{Class Diagrams}
\includegraphics[width=0.5\linewidth]{assets/class diagrams/generator.PNG}
\includegraphics[width=0.5\linewidth]{assets/class diagrams/solver.PNG}
\includegraphics[width=0.5\linewidth]{assets/class diagrams/maze.PNG}
\includegraphics[width=0.5\linewidth]{assets/class diagrams/node.PNG}


\subsection{Data Structures}
\subsubsection{Grid}
The Grid for the maze will be stored in a 2D array with each item being a Node object. For example, a 2x2 grid would look like: [[Node, Node], [Node, Node]]

\subsubsection{Prims}
For prim's algorithm maze generation, multi-dimensional arrays will be used for storing the nodes that are in the maze and the "frontier" -  a list of nodes that are adjacent to the current node and have not been visited. The frontier will be a 3D array, for example, [[[x, y], [available walls]], [[x, y], [available walls]], ...].

\subsection{Algorithms}
\subsubsection{Maze generating algorithms}
Pseudoscode for the maze generation algorithms.
\paragraph{prims}
\begin{verbatim}
    function prims(Grid)
        let inMaze = [[0,0]]
        let frontier = [
            [[0,1],["left"]],
            [[1,0],["top"]]
        ]
        
        while frontier.length > 0
            new <- frontier.pop(rand(0, frontier.length - 1))
            toAdd <- new[0]
            wall <- new[1][rand(0, new[1].length - 1)]
            inMaze.push(toAdd)

            if wall == "bottom"
                Grid.grid[toAdd[0]][toAdd[1]].wallBottom = false
            if wall == "left"
                Grid.grid[toAdd[0]][toAdd[1]].wallLeft = false
            if wall == "top" and toAdd[0] > 0
                Grid.grid[toAdd[0] - 1][toAdd[1]].wallBottom = false
            if wall == "right" and toAdd[1] < Grid.width - 1
                Grid.grid[toAdd[0]][toAdd[1] + 1].wallLeft = false
            
            possible <- [
                [toAdd[0]-1, toAdd[1]],
                [toAdd[0]+1,toAdd[1]],
                [toAdd[0],toAdd[1]-1],
                [toAdd[0], toAdd[1]+1]
            ]

            walls <- ["bottom", "top", "right", "left"]

            for i in range 4
                p <- possible[i]
                wall <- walls[i]
                if p[0] >= 0 and p[0] < Grid.height and p[1] >= 0 and p[1] < Grid.width
                    if p not in inMaze
                        found <- false
                        for v in frontier
                            if v[0] == p
                                v[1].push(wall)
                                found = true
                        end for
                        if not found
                            frontier.push([p, [wall]])
            end for
        end while
    end function
\end{verbatim}
\paragraph{Recusive backtracking}
\begin{verbatim}
    function recursiveBacktracking(Grid)
        unvisited <- []
        for row in Grid.grid
            for items in row
                unvisited.push(items)
            end for
        end for

        start <- unvisited.pop(rand(0, unvisited.length - 1))
        recursive_backtracking_run(Grid, unvisited, start, [])
    end function

    function recursive_backtracking_run(Grid, unvisited, current, previous)
        orientation_options <- []
        if current.x > 0 and Grid.grid[current.y][current.x - 1] in unvisited
            orientation_options.push("left")
        end if

        if current.y > 0 and Grid.grid[current.y - 1][current.x] in unvisited
            orientation_options.push("top")
        end if

        if current.x < Grid.width - 1 and Grid.grid[current.y][current.x + 1] in unvisited
            orientation_options.push("right")
        end if

        if current.y < Grid.height - 1 and Grid.grid[current.y + 1][current.x] in unvisited
            orientation_options.push("bottom")
        end if

        if orientation_options.length > 0
            orientation <- orientation_options[rand(0, orientation_options.length - 1)]
            previous.push(current)

            if orientation == "left"
                connecting_cell <- Grid.grid[current.y][current.x - 1]
                cell.wallLeft = false
            
            else if orientation == "bottom"
                connecting_cell <- Grid.grid[current.y + 1][current.x]
                cell.wallBottom = false
            
            else if orientation == "right"
                connecting_cell <- Grid.grid[current.y][current.x + 1]
                connecting_cell.wallLeft = false
            
            else if orientation == "top"
                connecting_cell <- Grid.grid[current.y - 1][current.x]
                connecting_cell.wallBottom = false
            end if

            unvisited.remove(connecting_cell)

            recursive_backtracking_run(Grid, unvisited, connecting_cell, previous)
        else
            if previous.length > 0
                new <- previous.pop()
                recursive_backtracking_run(Grid, unvisited, new, previous)
            end if
        end if
    end function
\end{verbatim}
\section{Evidence of Completeness}  
%out of 15 marks, argument for why the project is complete. Which algorithms have been used?

\section{Technical Solution}
\lstinputlisting[language=python]{../python api/lambda_function.py}
\lstinputlisting[language=python]{../python api/generator.py}
\lstinputlisting[language=python]{../python api/grid.py}
\lstinputlisting[language=JavaScript]{../react app/src/App.js}
\lstinputlisting[language=JavaScript]{../react app/src/components/Menu.jsx}
\lstinputlisting[language=JavaScript]{../react app/src/components/MenuKey.jsx}
\lstinputlisting[language=JavaScript]{../react app/src/components/DisplayGrid.jsx}
\lstinputlisting[language=JavaScript]{../react app/src/components/DisplayNode.jsx}

\section{Testing}

\section{Evaluation}
\end{document}